 因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。

在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可当我回过头来重新整理JS基础时，发现由于对它的模糊认知，导致了许多知识理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？浅复制与深复制有什么不同？闭包到底是什么？等等。

因此，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。

在学习内存空间之前，我们需要对三种数据结构有一个清晰的理解。他们分别是**堆(heap)，栈(stack)与队列(queue)**。



------

## 基本数据结构

------

### 栈

栈，只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。

### 堆

堆是基于散列算法的数据结构。

### 队列

- 队列是一种先进先出（FIFO）的数据结构。



## JavaScript中数据类型的存储

------

JavaScript中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。

### 基本数据类型

我们都知道JavaScript中的基本数据类型有：

- String
- Number
- Boolean
- Undefined
- Null
- Symbol（暂时不管）

基本数据类型都是一些简单的数据段，它们是存储在栈内存中。



### 引用数据类型

JavaScript中的引用数据类型有：

- Array
- Object

引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对**引用数据类型**的操作都是**操作对象的引用**而不是实际的对象。

可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。



为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解

```javascript
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```

![img](https://cdn.nlark.com/yuque/0/2022/png/33579416/1666485574958-27842d70-0a86-4821-8076-4ae0cb33e5cb.png)



当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。



在前端面试中我们常常会遇到这样一个类似的题目

```javascript
// demo01.js
var a = 20;
var b = a;
b = 30;

// 这时a的值是多少？
```



```javascript
// demo02.js
var m = { a: 10, b: 20 }
var n = m;
n.a = 15;

// 这时m.a的值是多少
```



在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。

![img](https://cdn.nlark.com/yuque/0/2022/png/33579416/1666485748391-8e023240-b89e-4bde-adc8-85cef4dc8837.png)





在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。

因此当我改变n时，m也发生了变化。这就是引用类型的特性。

![img](https://cdn.nlark.com/yuque/0/2022/png/33579416/1666485783805-8a2fce1b-0248-440e-9610-ad5b70fd9192.png)





### 复制



#### 基本数据类型

对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值，很容易理解。

#### 引用数据类型

如果对于数组、对象这样的引用数据类型而言，复制的时候就会有所区别了：

系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。



### 为什么？

为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？

1. 堆比栈大，栈比对速度快。
2. 基础数据类型比较稳定，而且相对来说占用的内存小。
3. 引用数据类型大小是动态的，而且是无限的。
4. 堆内存是无序存储，可以根据引用直接获取。





## 内存空间管理



了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。



```javascript
var a = 20;  // 在内存中给数值变量分配空间
alert(a + 100);  // 使用内存
a = null; // 使用完毕之后，释放内存空间
```



第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。



JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。



在JavaScript中，最常用的是通过**标记清除**的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个**释放引用**的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。**而在适当的时候解除引用，是为页面获得更好性能的一个重要方式**。


需要注意的是，在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要释放内存空间则很难判断，因此在我们的开发中，原则上应该避免使用全局变量。

